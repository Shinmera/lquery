<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>Lquery</title> <meta name="viewport" content="width=device-width"/> <meta name="description" content="A library to allow jQuery-like HTML/DOM manipulation."/> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"/> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }
      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
          text-align: center;
      }
      body>header img{
          max-width: 50%;
      }
      img{
          max-width: 100%;
          max-height: 100%;
      }
      code{
          font-family: Consolas, Inconsolata, monospace;
      }
      a{
          text-decoration: none;
          color: #0055AA;
      }
      a img{
          border: none;
      }
      #documentation{
          text-align: justify;
      }
      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }
      #documentation img{
          margin: 5px;
      }
      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }
      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1><img alt="lquery" src="lquery-logo.png"/></h1> <span class="version">3.2.0</span> <p class="description">A library to allow jQuery-like HTML/DOM manipulation.</p> </header> <main> <article id="documentation">  <div><h2>About lQuery</h2> <p>lQuery is a DOM manipulation library written in Common Lisp, inspired by and based on the <a href="http://jquery.com/">jQuery</a> syntax and functions. It uses <a href="http://shinmera.github.io/plump">Plump</a> and <a href="http://shinmera.github.io/CLSS/">CLSS</a> as DOM and selector engines. The main idea behind lQuery is to provide a simple interface for crawling and modifying HTML sites, as well as to allow for an alternative approach to templating.</p> <h2>How To</h2> <p>Load lQuery with ASDF or Quicklisp.</p> <pre><code>(ql:quickload :lquery)
</code></pre> <p>First, lQuery needs to be initialized with a document to work on:</p> <pre><code>(<a href="http://l1sp.org/cl/defvar">defvar</a> *doc* (<a href="#LQUERY:$">lquery:$</a> (<a href="#LQUERY:INITIALIZE">initialize</a> (asdf:system-relative-pathname :lquery &quot;test.html&quot;))))
</code></pre> <p>After that, you can use the <code>$</code> macro to select and manipulate the DOM:</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> *doc* &quot;article&quot;)
(<a href="#LQUERY:$">lquery:$</a> *doc* 
  &quot;article&quot;
  (<a href="#LQUERY-FUNCS:ADD-CLASS">add-class</a> &quot;fancy&quot;)
  (<a href="#LQUERY-FUNCS:ATTR">attr</a> &quot;foo&quot; &quot;bar&quot;))
</code></pre> <p>To render the HTML to a string use <code><a href="#LQUERY-FUNCS:SERIALIZE">SERIALIZE</a></code>. If you want to save it to a file directly, there's also <code><a href="#LQUERY-FUNCS:WRITE-TO-FILE">WRITE-TO-FILE</a></code>.</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> *doc* (<a href="#LQUERY-FUNCS:SERIALIZE">serialize</a>))
(<a href="#LQUERY:$">lquery:$</a> *doc* (<a href="#LQUERY-FUNCS:WRITE-TO-FILE">write-to-file</a> #p&quot;~/plump-test.html&quot;))
</code></pre> <p>So a quick file manipulation could look something like this:</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> (<a href="#LQUERY:INITIALIZE">initialize</a> (asdf:system-relative-pathname :lquery &quot;test.html&quot;))
  &quot;article&quot;
  (<a href="#LQUERY-FUNCS:APPEND-TO">append-to</a> &quot;#target&quot;)
  (<a href="#LQUERY-FUNCS:ADD-CLASS">add-class</a> &quot;foo&quot;)
  (<a href="#LQUERY-FUNCS:ROOT">root</a>)
  (<a href="#LQUERY-FUNCS:WRITE-TO-FILE">write-to-file</a> #p&quot;~/plump-test.html&quot;))
</code></pre> <p>Aside from using selectors as the first step, it's also possible to use any other variable or list and operate on it. <br/> Since 2.0: Literal function calls need to be added with <code><a href="#LQUERY:INLINE">INLINE</a></code>.
Note that the result of the inline function will be used as if literally put in place. For example, an inlined function that evaluates
to a string will result in a CSS-select.</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> (<a href="#LQUERY:INLINE">inline</a> (<a href="http://l1sp.org/cl/list">list</a> node-a node-b))
  &quot;article&quot;
  (<a href="#LQUERY-FUNCS:SERIALIZE">serialize</a>))
</code></pre> <p>Selectors can come at any point in the sequence of lQuery operations and will always act on the current set of elements.
If an operation evaluates to a list, array, vector or a single node, the current set of elements is set to this result.</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> *doc*
  &quot;a&quot;
  (<a href="#LQUERY-FUNCS:TEXT">text</a> &quot;Link&quot;)
  (<a href="#LQUERY:INLINE">inline</a> (<a href="#LQUERY:$">lquery:$</a> *doc* &quot;p&quot;))
  (<a href="#LQUERY-FUNCS:TEXT">text</a> &quot;Paragraph&quot;))
</code></pre> <p>This is equivalent to the following:</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> *doc*
  &quot;a&quot; (<a href="#LQUERY-FUNCS:TEXT">text</a> &quot;Link&quot;))
(<a href="#LQUERY:$">lquery:$</a> *doc*
  &quot;p&quot; (<a href="#LQUERY-FUNCS:TEXT">text</a> &quot;Paragraph&quot;))
</code></pre> <p>Functions in the argument list will be translated to a function invocation with the current list of elements as their argument.</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> *doc*
  &quot;a&quot; #'(<a href="http://l1sp.org/cl/lambda">lambda</a> (els) (<a href="http://l1sp.org/cl/aref">aref</a> els 0)))
</code></pre> <p>lQuery<sup>2.0</sup> also supports compile-time evaluation of forms, whose results are then put in place of their function calls:</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> *doc* (<a href="#LQUERY:EVAL">eval</a> (<a href="http://l1sp.org/cl/format">format</a> NIL &quot;~a&quot; *selector*)))
</code></pre> <p>Keep in mind that the lexical environment is not the same at compile-time as at run-time.</p> <p>Often times you'll also want to retrieve multiple, different values from your current set of nodes. To make this more convenient, you can use the <code><a href="#LQUERY-MACROS:COMBINE">COMBINE</a></code> form:</p> <pre><code>(<a href="#LQUERY:$">lquery:$</a> *doc*
  &quot;a&quot;
  (<a href="#LQUERY-MACROS:COMBINE">combine</a> (<a href="#LQUERY-FUNCS:ATTR">attr</a> :href) (<a href="#LQUERY-FUNCS:TEXT">text</a>))
  (<a href="#LQUERY-FUNCS:MAP-APPLY">map-apply</a> #'(<a href="http://l1sp.org/cl/lambda">lambda</a> (url text) (<a href="http://l1sp.org/cl/format">format</a> T &quot;[~a](~a)&quot; text url))))
</code></pre> <p>lQuery uses vectors internally to modify and handle sets of nodes. These vectors are usually modified instead of copied to avoid unnecessary resource allocation. This however also means that lQuery functions are possibly side-effecting. If you pass an adjustable vector into lQuery through <code><a href="#LQUERY:INLINE">INLINE</a></code> or similar, it will not be copied and therefore side-effects might occur. lQuery will automatically copy everything else that isn't an adjustable vector through <code><a href="#LQUERY:ENSURE-PROPER-VECTOR">ENSURE-PROPER-VECTOR</a></code>. If you do want to pass in an adjustable vector, but make sure it doesn't affect it, use <code><a href="#LQUERY:COPY-PROPER-VECTOR">COPY-PROPER-VECTOR</a></code>.</p> <h2>Test Suite</h2> <p>To ensure that functions are at least somewhat stable in their behaviour, lQuery includes a test suite. You can load this through Quicklisp/ASDF with</p> <pre><code>(ql:quickload :lquery-test)
(lquery-test:run)
</code></pre> <p>The tests are rather loose, but should cover all functions to at least behave mostly according to expectation.</p> <h2>Extending lQuery<sup>3.1</sup></h2> <p>lQuery allows extension in a couple of ways. The most important of which are node functions themselves, which come in two flavours: lquery-funs and lquery-list-funs.
Any lquery function resides in the package <code>LQUERY-FUNCS</code>, which is automatically scanned by the $ macro. The two macros responsible for defining new lquery functions automatically place the resulting operations in this package for you.</p> <pre><code>(<a href="#LQUERY:DEFINE-LQUERY-FUNCTION">define-lquery-function</a> name (node-name &amp;rest arguments) &amp;body body)
(<a href="#LQUERY:DEFINE-LQUERY-LIST-FUNCTION">define-lquery-list-function</a> name (vector-name &amp;rest arguments) &amp;body body)
</code></pre> <p>Any function generated by these macros can be called either with a single node or a vector of nodes. In the case of a regular node operation, if it receives a vector of nodes, the function is called once for each node and the results are collected into a vector, which is then returned. If it receives a single node, only a single result is returned. In the case of a node list function, the return value can be either a vector or a single value, depending on what the goal of the operation is. It is expected that node list functions will modify the given vector directly in order to avoid unnecessary copying.</p> <p>Some constructs would be very cumbersome to write as functions, or would simply be more suited in the form of a macro. To allow for this, lQuery<sup>3.1</sup> includes a mechanism of <code>$</code> local macros. The previously mentioned forms like <code><a href="#LQUERY:INLINE">INLINE</a></code> are handled through this system. Just like lquery functions, lquery macros reside in their own package <code>LQUERY-MACROS</code>. The responsible macro for defining new lquery macros will automatically place it in there for you.</p> <pre><code>(<a href="#LQUERY:DEFINE-LQUERY-MACRO">define-lquery-macro</a> name (previous-form &amp;rest arguments) &amp;body body)
</code></pre> <p>The $ macro itself can be extended as well by providing additional argument- or value-handlers. The following two macros make this possible:</p> <pre><code>(<a href="#LQUERY:DEFINE-ARGUMENT-HANDLER">define-argument-handler</a> type (argument-name operator-name) &amp;body body)
</code></pre> <p>Argument handlers transform the arguments at compile-time. For example, this would allow an extension to turn literal arrays into lists so they can be processed as well.</p> <pre><code>(<a href="#LQUERY:DEFINE-VALUE-HANDLER">define-value-handler</a> type (variable-name operator-name) &amp;body body)
</code></pre> <p>Value handlers on the other hand determine the action at run-time. This is mostly useful for defining special actions on certain variable values.</p> <h2>What's New</h2> <h3><a name="3.1.0"/>3.1.0</h3> <p>Renamed <code>DEFINE-NODE-\*</code> macros into more sensible <code>DEFINE-LQUERY-*</code>.
Added macro system, new standard <code><a href="#LQUERY-MACROS:COMBINE">COMBINE</a></code> macro.</p> <h3><a name="3.0.0"/>3.0.0</h3> <p>Complete rewrite of everything. This version is <strong>compatibility breaking</strong>. While the node functions themselves perform just the same as before (with one or two exceptions), lQuery now uses vectors instead of lists internally. If you ever relied on lQuery return values, this version will most likely break your code. Effort has been made to keep upgrading as simple as possible though; passing lists into an lQuery chain automatically transforms it for example.</p> <p>Thanks to the change to Plump, lQuery is now also able to parse almost any kind of X/HT/ML document, which was not well possible previously. And thanks to switching to CLSS, lQuery is now much faster at selecting nodes from the DOM.</p> <h3><a name="2.0.0"/>2.0.0</h3> <p>Added extension system and <code><a href="#LQUERY:INLINE">INLINE</a></code>, <code><a href="#LQUERY:EVAL">EVAL</a></code> handling. Revamped base macros to be more stable and simple.</p> <h2>Further Reading</h2> <ul> <li><a href="https://shinmera.github.io/lquery">lQuery</a>'s symbol index.</li> <li><a href="https://shinmera.github.io/plump">Plump</a>, the HTML parser and DOM library lQuery is based on.</li> <li><a href="https://shinmera.github.io/CLSS">CLSS</a>, the CSS-selector DOM traversal engine.</li> <li><a href="https://shinmera.github.io/clip">Clip</a>, a templating system based on lQuery.</li> </ul> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>lquery</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  Â© <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .  This library can be obtained on <a href="https://github.com/Shinmera/lquery">https://github.com/Shinmera/lquery</a>.  </article>  <article id="symbol-index"> <h2>Package Index</h2> <ul><li class="package"> <h3> <a name="LQUERY" href="#LQUERY">LQUERY</a> <span class="nicknames">(ORG.SHIRAKUMO.LQUERY)</span> </h3> <ul><li> <a name="LQUERY:*LQUERY-MASTER-DOCUMENT*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#LQUERY:*LQUERY-MASTER-DOCUMENT*">*LQUERY-MASTER-DOCUMENT*</a></code></h4>  </header> <div class="docstring"><pre>The master document used at the beginning of a chain.</pre></div> </article> </li><li> <a name="LQUERY:COPY-PROPER-VECTOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:COPY-PROPER-VECTOR">COPY-PROPER-VECTOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">SEQUENCE &amp;KEY (TRANSFORM (FUNCTION IDENTITY))</code><code>)</code>  </header> <div class="docstring"><pre>Copies the sequence into a new proper vector.</pre></div> </article> </li><li> <a name="LQUERY:ENSURE-PROPER-VECTOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:ENSURE-PROPER-VECTOR">ENSURE-PROPER-VECTOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">VAR</code><code>)</code>  </header> <div class="docstring"><pre>Ensure that the variable is a proper vector.</pre></div> </article> </li><li> <a name="LQUERY:EVAL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:EVAL">EVAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">ORIGINAL-EXP</code><code>)</code>  </header> <div class="docstring"><pre>Evaluate the argument in a null lexical environment, returning the
   result or results.</pre></div> </article> </li><li> <a name="LQUERY:INITIALIZE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:INITIALIZE">INITIALIZE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">DOCUMENT</code><code>)</code>  </header> <div class="docstring"><pre>Sets the *lquery-master-document* variable to the provided document.</pre></div> </article> </li><li> <a name="LQUERY:LOAD-PAGE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:LOAD-PAGE">LOAD-PAGE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FILE-OR-STRING</code><code>)</code>  </header> <div class="docstring"><pre>Load the given file or string into a HTML DOM.</pre></div> </article> </li><li> <a name="LQUERY:MAKE-PROPER-VECTOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:MAKE-PROPER-VECTOR">MAKE-PROPER-VECTOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;KEY (SIZE 0) INITIAL-ELEMENT INITIAL-CONTENTS (FILL-POINTER T)</code><code>)</code>  </header> <div class="docstring"><pre>Creates a new proper vector.</pre></div> </article> </li><li> <a name="LQUERY:PARSE-HTML"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:PARSE-HTML">PARSE-HTML</a></code></h4> <code class="qualifiers"></code> <code class="arguments">HTML</code><code>)</code>  </header> <div class="docstring"><pre>Build the given string into DOM objects related to the master document.</pre></div> </article> </li><li> <a name="LQUERY:$"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:$">$</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;BODY ACTIONS</code><code>)</code>  </header> <div class="docstring"><pre>Performs lQuery operations on the current document.

Each argument is executed in sequence. The arguments are evaluated according to the defined argument-handlers. By default, the following cases are handled: 
  * STRING    Translates to a CLSS:QUERY on the current elements.
  * FUNCTION  Translates to a function call with the list of nodes as argument.
  * SYMBOL    Delegates to the value handlers.
  * LIST      Lists are transformed according to their first element, which must be a symbol. If the symbol's name corresponds to a function found in the LQUERY-MACROS package, The form is assembled according to that function. Otherwise if it corresponds to an LQUERY-FUNCS function, it is expanded into a call to that function. If the symbol cannot be found in either package, it is put back in place, but the call itself is assembled like so: (FUNCTION PREVIOUS-RESULT ARGUMENT*)

Values are handled at runtime according to the defined variable-handlers. By default, the following cases are handled at run time:
  * STRING    Performs a CLSS:QUERY on the current elements.
  * DOM:NODE  Replaces the current set of nodes with just this node.  
  * FUNCTION  Calls the given function with the current set of nodes as argument.
  * LIST      Lists are transformed into a proper vector.
  * ARRAY     Arrays are transformed into a proper vector.
  * VECTOR    Vectors that are not adjustable are transformed into a proper vector.
  * T         Any other value simply replaces the current list of nodes.</pre></div> </article> </li><li> <a name="LQUERY:$1"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:$1">$1</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;BODY ACTIONS</code><code>)</code>  </header> <div class="docstring"><pre>This is the same as $, except it automatically uses NODE at the end and thus only returns the first result, if any.</pre></div> </article> </li><li> <a name="LQUERY:DEFINE-ARGUMENT-HANDLER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:DEFINE-ARGUMENT-HANDLER">DEFINE-ARGUMENT-HANDLER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TYPE (ARGUMENT-NAME OPERATOR-NAME) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new argument handler that decides what to do with a certain type of argument at compile-time.

TYPE          --- A type or EQL specifier.
ARGUMENT-NAME --- Symbol bound to the argument.
OPERATOR-NAME --- Symbol bound to the object being operated on.
BODY          ::= form*</pre></div> </article> </li><li> <a name="LQUERY:DEFINE-LQUERY-FUNCTION"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:DEFINE-LQUERY-FUNCTION">DEFINE-LQUERY-FUNCTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME (NODE-NAME &amp;REST ARGUMENTS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new node function. This is the main mechanism by which node manipulations are defined.
All lquery functions are automatically created in the lquery-funcs package.

NAME      --- A symbol naming the lquery function. Automatically interned in the LQUERY-FUNCS package.
NODE-NAME --- Symbol bound to the current node.
ARGUMENTS --- A lambda-list specifying the arguments for the function.
BODY      ::= form*</pre></div> </article> </li><li> <a name="LQUERY:DEFINE-LQUERY-LIST-FUNCTION"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:DEFINE-LQUERY-LIST-FUNCTION">DEFINE-LQUERY-LIST-FUNCTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME (VECTOR-NAME &amp;REST ARGUMENTS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new function that operates on the current node array instead of individual elements.
All lquery functions are automatically created in the lquery-funcs package.

NAME        --- A symbol naming the lquery function. Automatically interned in the LQUERY-FUNCS package.
VECTOR-NAME --- Symbol bound to the node vector.
ARGUMENTS   --- A lambda-list specifying the arguments for the function.
BODY        ::= form*</pre></div> </article> </li><li> <a name="LQUERY:DEFINE-LQUERY-MACRO"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:DEFINE-LQUERY-MACRO">DEFINE-LQUERY-MACRO</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME (PREVIOUS-FORM &amp;REST ARGUMENTS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Define a new lquery local macro.
All lquery macros are automatically created in the lquery-macros package.

NAME          --- A symbol naming the lquery macro. Automatically interned in the LQUERY-MACROS package.
PREVIOUS-FORM --- Symbol bound to the so far assembled form, the previous value so to speak.
ARGUMENTS     --- A lambda-list specifying the arguments for the macro (note that this must be a standard lambda-list).
BODY          ::= form*</pre></div> </article> </li><li> <a name="LQUERY:DEFINE-LQUERY-SUBROUTINE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:DEFINE-LQUERY-SUBROUTINE">DEFINE-LQUERY-SUBROUTINE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME (&amp;REST ARGUMENTS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a shorthand function. The body is a set of lQuery instructions as you'd use in $.

NAME      --- A symbol naming the subroutine. Automatically interned in the LQUERY-FUNCS package.
ARGUMENTS --- A lambda-list specifying the arguments for the function.
BODY      ::= lquery-form*</pre></div> </article> </li><li> <a name="LQUERY:DEFINE-VALUE-HANDLER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:DEFINE-VALUE-HANDLER">DEFINE-VALUE-HANDLER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TYPE (VARIABLE-NAME OPERATOR-NAME) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new symbol handler that decides what to do with a certain type of symbol at run-time (variable type).

TYPE          --- A type or EQL specifier.
VARIABLE-NAME --- Symbol bound to the argument.
OPERATOR-NAME --- Symbol bound to the object being operated on.
BODY          ::= form*</pre></div> </article> </li><li> <a name="LQUERY:WITH-MASTER-DOCUMENT"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY:WITH-MASTER-DOCUMENT">WITH-MASTER-DOCUMENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(&amp;OPTIONAL (DOC '*LQUERY-MASTER-DOCUMENT*)) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Surrounds the body in a binding for the *lquery-master-document* to ensure it does not get clobbered.</pre></div> </article> </li></ul> </li><li class="package"> <h3> <a name="LQUERY-FUNCS" href="#LQUERY-FUNCS">LQUERY-FUNCS</a> <span class="nicknames">(ORG.SHIRAKUMO.LQUERY.FUNCS)</span> </h3> <ul><li> <a name="LQUERY-FUNCS:ADD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:ADD">ADD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Add elements to the set of matched elements.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:ADD-CLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:ADD-CLASS">ADD-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST CLASSES</code><code>)</code>  </header> <div class="docstring"><pre>Adds the specified class(es) to the set of matched elements.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:AFTER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:AFTER">AFTER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert content (in html-string or node-list form) after each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:ANCESTOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:ANCESTOR">ANCESTOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Find the common ancestor of all elements.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:APPEND"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:APPEND">APPEND</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert content (in html-string or node-list form) to the end of each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:APPEND-TO"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:APPEND-TO">APPEND-TO</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert every element to the end of the target(s).</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:ATTR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:ATTR">ATTR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST PAIRS</code><code>)</code>  </header> <div class="docstring"><pre>Retrieve or set attributes on a node.
The value on a node is turned into a string using PRINC-TO-STRING.
If a value is NIL, the associated attribute is removed.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:BEFORE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:BEFORE">BEFORE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert content (in html-string or node-list form) before each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:CHILD-INDEX"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:CHILD-INDEX">CHILD-INDEX</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Returns the index of the element within its parent, also counting text nodes. See index() otherwise.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:CHILDREN"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:CHILDREN">CHILDREN</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get the children of each element, optionally filtered by a selector.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:CLONE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:CLONE">CLONE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Create a deep copy of the set of matched elements.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:CLOSEST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:CLOSEST">CLOSEST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
If no matching element can be found the root is entered instead.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:CONTAINS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:CONTAINS">CONTAINS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES STRING</code><code>)</code>  </header> <div class="docstring"><pre>Select all elements that contain the specified text.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:CONTENTS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:CONTENTS">CONTENTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES</code><code>)</code>  </header> <div class="docstring"><pre>Get the children of each element, including text and comment nodes.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:CSS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:CSS">CSS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST PAIRS</code><code>)</code>  </header> <div class="docstring"><pre>Retrieve or set css style attributes on a node.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:DATA"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:DATA">DATA</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST PAIRS</code><code>)</code>  </header> <div class="docstring"><pre>Retrieve or set data attributes on a node. This is a convenience method and uses attr in the back.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:DEEPEST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:DEEPEST">DEEPEST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Returns the innermost (left-bound) child element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:DETACH"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:DETACH">DETACH</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Removes the node (optionally filtered by the selector) from the document. Alias for remove()</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:EACH"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:EACH">EACH</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES FUN &amp;KEY REPLACE</code><code>)</code>  </header> <div class="docstring"><pre>Execute the specified function on each element until NIL is returned or all elements have been processed. The original set of elements is returned if replace is NIL.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:EMPTY"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:EMPTY">EMPTY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Remove all child nodes from the set of matched elements.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:EMPTY-P"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:EMPTY-P">EMPTY-P</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Check if the node contains no children and/or only empty (whitespace) text nodes. If it is empty, T is returned, otherwise NIL.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:EQ"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:EQ">EQ</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES INDEX</code><code>)</code>  </header> <div class="docstring"><pre>Reduce the set of matched elements to the one at the specified index</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:EVEN"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:EVEN">EVEN</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Selects even elements, 1-indexed</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:FILTER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:FILTER">FILTER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES SELECTOR-OR-FUNCTION</code><code>)</code>  </header> <div class="docstring"><pre>Reduce the set of matched elements to those that match the selector or pass the function's test.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:FIND"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:FIND">FIND</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES SELECTOR-OR-FUNCTION &amp;KEY (TEST-SELF NIL)</code><code>)</code>  </header> <div class="docstring"><pre>Get the descendants of each element filtered by selector or function.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:FIRST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:FIRST">FIRST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Reduce the set of matched elements to the first in the set.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:GT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:GT">GT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES INDEX</code><code>)</code>  </header> <div class="docstring"><pre>Select all elements at a greater than index(0) within the matched set.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:HAS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:HAS">HAS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Reduce the set of matched elements to those that have a descendant that matches the selector or element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:HAS-CLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:HAS-CLASS">HAS-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Determine whether any of the matched elements are assigned to the given class.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:HIDE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:HIDE">HIDE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Hide the matched elements (short for (css &quot;display&quot; &quot;none&quot;)).</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:HTML"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:HTML">HTML</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;OPTIONAL NEW-CONTENT</code><code>)</code>  </header> <div class="docstring"><pre>Get the HTML contents of the elements or set the HTML contents of every matched element. If the new content is not a string, it is turned into one as per PRINC-TO-STRING.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:HTML-FILE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:HTML-FILE">HTML-FILE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES PATHNAME</code><code>)</code>  </header> <div class="docstring"><pre>Read an HTML file and insert its contents into each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:INDEX"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:INDEX">INDEX</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Find the index of the node within its parent.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:INITIALIZE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:INITIALIZE">INITIALIZE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES DOCUMENT</code><code>)</code>  </header> <div class="docstring"><pre>Re-initializes lQuery with a new page.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:INSERT-AFTER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:INSERT-AFTER">INSERT-AFTER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert every element after the target.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:INSERT-BEFORE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:INSERT-BEFORE">INSERT-BEFORE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert every element before the target.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:IS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:IS">IS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Check the current elements against a selector or list of elements and return true if at least one of them matches.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:IS-EMPTY"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:IS-EMPTY">IS-EMPTY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Check if the node contains no children and/or only empty (whitespace) text nodes. If it is empty, T is returned, otherwise NIL.
Alias of EMPTY-P</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:LAST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:LAST">LAST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Reduce the set of matched elements to the final one in the set.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:LENGTH"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:LENGTH">LENGTH</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Returns the number of elements in the list.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:LT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:LT">LT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES INDEX</code><code>)</code>  </header> <div class="docstring"><pre>Select all elements at an index less than the index within the matched set.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:MAP"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:MAP">MAP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES FUNCTION</code><code>)</code>  </header> <div class="docstring"><pre>Pass each element through a function (which has to accept one argument, the node), returning the list of all results.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:MAP-APPLY"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:MAP-APPLY">MAP-APPLY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES FUNCTION</code><code>)</code>  </header> <div class="docstring"><pre>Pass each element through a function by apply, returning the vector of all results.
This is commonly useful in combination with COMBINE.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:NEXT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:NEXT">NEXT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get the immediately following sibling of each element (if there is one). If a selector is provided, the sibling is only included if it matches.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:NEXT-ALL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:NEXT-ALL">NEXT-ALL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get all following siblings of each element. If a selector is provided, the sibling is only included if it matches.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:NEXT-UNTIL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:NEXT-UNTIL">NEXT-UNTIL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Get all following silings of each element up to (excluding) the element matched by the selector or node list.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:NODE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:NODE">NODE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES &amp;OPTIONAL (N 0)</code><code>)</code>  </header> <div class="docstring"><pre>Return the specified node (default first) directly, without encompassing it into a vector if it exists. Otherwise return NIL.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:NOT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:NOT">NOT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Remove matching elements from the working elements.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:NOT-EMPTY"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:NOT-EMPTY">NOT-EMPTY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Check if the node contains no children and/or only empty (whitespace) text nodes. If the node is effectively empty NIL is returned, otherwise T</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:ODD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:ODD">ODD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Select all odd elements from the current set, 1-indexed.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PARENT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PARENT">PARENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get the parent of each element, optionally filtered by a selector.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PARENTS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PARENTS">PARENTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get the ancestors of each element, optionally filtered by a selector. Closest parent first.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PARENTS-UNTIL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PARENTS-UNTIL">PARENTS-UNTIL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Get the ancestors of each element, up to (excluding) the element matched by the selector or node list. Closest parent first</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PREPEND"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PREPEND">PREPEND</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert content, specified by the parameter, to the beginning of each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PREPEND-TO"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PREPEND-TO">PREPEND-TO</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Insert every element to the beginning of the target(s).</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PREV"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PREV">PREV</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get the immediately preceding sibling of each element (if there is one). If a selector is provided, the sibling is only included if it matches.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PREV-ALL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PREV-ALL">PREV-ALL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get all preceeding siblings of each element. If a selector is provided, the sibling is only included if it matches.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:PREV-UNTIL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:PREV-UNTIL">PREV-UNTIL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Get all preceeding silings of each element down to (excluding) the element matched by the selector or node list.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:REMOVE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:REMOVE">REMOVE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Remove the set of matched elements from the DOM.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:REMOVE-ATTR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:REMOVE-ATTR">REMOVE-ATTR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST ATTRIBUTES</code><code>)</code>  </header> <div class="docstring"><pre>Remove attributes from each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:REMOVE-CLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:REMOVE-CLASS">REMOVE-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST CLASSES</code><code>)</code>  </header> <div class="docstring"><pre>Remove classes from each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:REMOVE-DATA"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:REMOVE-DATA">REMOVE-DATA</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST DATA</code><code>)</code>  </header> <div class="docstring"><pre>Remove data attributes from each element. This is a convenience method and uses remove-attr in the back.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:REPLACE-ALL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:REPLACE-ALL">REPLACE-ALL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES SELECTOR-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Replace each in the set of matched elements with the current nodes.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:REPLACE-WITH"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:REPLACE-WITH">REPLACE-WITH</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Replace each element with the provided new content and return the set of elements that was removed.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:ROOT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:ROOT">ROOT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Returns to the root. Essentially traverses up the tree of the first element in the set until the root is reached.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:SERIALIZE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:SERIALIZE">SERIALIZE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;OPTIONAL (STREAM NIL)</code><code>)</code>  </header> <div class="docstring"><pre>Serialize the node into a string.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:SHOW"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:SHOW">SHOW</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Display the matched elements (short for (css :display 'block'))</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:SIBLINGS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:SIBLINGS">SIBLINGS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;OPTIONAL SELECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Get the siblings of each element, optionally filtered by a selector.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:SIZE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:SIZE">SIZE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Return the number of elements in the list.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:SLICE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:SLICE">SLICE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES START &amp;OPTIONAL END</code><code>)</code>  </header> <div class="docstring"><pre>Reduce the set of matched elements to a subset specified by a range of indices</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:SPLICE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:SPLICE">SPLICE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Splice the element's contents in place of itself.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:TEXT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:TEXT">TEXT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;OPTIONAL (TEXT NIL T-S-P)</code><code>)</code>  </header> <div class="docstring"><pre>Get the combined text contents of each element, including their descendants. If text is set, all text nodes are removed and a new text node is appended to the end of the node. If text is NIL, all direct text nodes are removed from the node. If text is not a string, it is transformed into one by PRINC-TO-STRING.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:TOGGLE-CLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:TOGGLE-CLASS">TOGGLE-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;REST CLASSES</code><code>)</code>  </header> <div class="docstring"><pre>Add or remove one or more classes from each element, depending on their presence within the element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:UNWRAP"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:UNWRAP">UNWRAP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE</code><code>)</code>  </header> <div class="docstring"><pre>Remove the parents of the set of matched elements from the DOM, inserting the parents children in place of it.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:VAL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:VAL">VAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODE &amp;OPTIONAL (VALUE NIL V-P)</code><code>)</code>  </header> <div class="docstring"><pre>Get the current values or set the value of every matched element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:WRAP"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:WRAP">WRAP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Wrap an HTML structure around each element. Note that always the first node of the structure to wrap is chosen.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:WRAP-ALL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:WRAP-ALL">WRAP-ALL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Wrap an HTML structure around all elements and put it in place of the first element, removing all other elements from their position.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:WRAP-INNER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:WRAP-INNER">WRAP-INNER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES HTML-OR-NODES</code><code>)</code>  </header> <div class="docstring"><pre>Wrap an HTML structure around the contents of each element.</pre></div> </article> </li><li> <a name="LQUERY-FUNCS:WRITE-TO-FILE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-FUNCS:WRITE-TO-FILE">WRITE-TO-FILE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WORKING-NODES FILE &amp;KEY (IF-DOES-NOT-EXIST :CREATE) (IF-EXISTS :SUPERSEDE)</code><code>)</code>  </header> <div class="docstring"><pre>Write the serialized node to the file. Note that always only the first element is written.</pre></div> </article> </li></ul> </li><li class="package"> <h3> <a name="LQUERY-MACROS" href="#LQUERY-MACROS">LQUERY-MACROS</a> <span class="nicknames">(ORG.SHIRAKUMO.LQUERY.MACROS)</span> </h3> <ul><li> <a name="LQUERY-MACROS:COMBINE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-MACROS:COMBINE">COMBINE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;REST CALLS</code><code>)</code>  </header> <div class="docstring"><pre>COMBINES multiple lquery function calls into one by gathering them into a list for each element.

 ($ (combine (text) (attr :a))) would be  equivalent to 
 ($ (map #'(lambda (node) (list (lquery-funcs:text node) (lquery-funcs:attr node :a)))))
This construct is especially useful in combination with MAP-APPLY.</pre></div> </article> </li><li> <a name="LQUERY-MACROS:EVAL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-MACROS:EVAL">EVAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES FORM</code><code>)</code>  </header> <div class="docstring"><pre>Evaluates the form at compile-time and puts its resulting value in place.</pre></div> </article> </li><li> <a name="LQUERY-MACROS:FUNCTION"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-MACROS:FUNCTION">FUNCTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES NAME</code><code>)</code>  </header> <div class="docstring"><pre>Macro to allow #'foo to be used in lquery chains.</pre></div> </article> </li><li> <a name="LQUERY-MACROS:INITIALIZE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-MACROS:INITIALIZE">INITIALIZE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES &amp;REST INIT-CALLS</code><code>)</code>  </header> <div class="docstring"><pre>See lquery function INITIALIZE.

This is merely a performance macro to avoid the unnecessary default allocation of a vector.</pre></div> </article> </li><li> <a name="LQUERY-MACROS:INLINE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#LQUERY-MACROS:INLINE">INLINE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NODES FORM</code><code>)</code>  </header> <div class="docstring"><pre>Treats the form as if the evaluated value was put literally in place.

See <a href="NIL">DETERMINE-VALUE.</a></pre></div> </article> </li></ul> </li></ul> </article>  </main> </body> </html> 